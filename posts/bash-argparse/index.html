<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Parsing command line arguments in Bash | Lucas Viana's ruminations</title><meta name=keywords content><meta name=description content="The best ways to parse arguments, and some script skeletons"><meta name=author content="Lucas Viana"><link rel=canonical href=https://lucas-viana.com/posts/bash-argparse/><link crossorigin=anonymous href=/assets/css/stylesheet.8b523f1730c922e314350296d83fd666efa16519ca136320a93df674d00b6325.css integrity="sha256-i1I/FzDJIuMUNQKW2D/WZu+hZRnKE2MgqT32dNALYyU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://lucas-viana.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lucas-viana.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lucas-viana.com/favicon-32x32.png><link rel=apple-touch-icon href=https://lucas-viana.com/apple-touch-icon.png><link rel=mask-icon href=https://lucas-viana.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Parsing command line arguments in Bash"><meta property="og:description" content="The best ways to parse arguments, and some script skeletons"><meta property="og:type" content="article"><meta property="og:url" content="https://lucas-viana.com/posts/bash-argparse/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-20T14:50:00+01:00"><meta property="article:modified_time" content="2023-02-20T14:50:00+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Parsing command line arguments in Bash"><meta name=twitter:description content="The best ways to parse arguments, and some script skeletons"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"","item":"https://lucas-viana.com/posts/"},{"@type":"ListItem","position":3,"name":"Parsing command line arguments in Bash","item":"https://lucas-viana.com/posts/bash-argparse/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Parsing command line arguments in Bash","name":"Parsing command line arguments in Bash","description":"The best ways to parse arguments, and some script skeletons","keywords":[],"articleBody":"If you don’t have a CLI option parser in your scripts, you don’t have scripts, you have childish cake recipes.\nAs a software developer, you are the product of the systems you’ve built to assist you in your thinking. I’ve heard the following phrase somewhere, so I won’t take credit:\nWe should minize the time spent getting in position to think.\nThen we should be writing scripts that are capable of handling our use-cases efficiently, without the constant need for us to go in and hack it up further.\nThe goal We want to write our Bash scripts so we can invoke them with a multitude of input options, so the script does the work without us needing to open it in the editor.\nWe also want scritps that we can simply ./call-it --help. And quickly be reminded of the syntax to invoke it.\nParsing arguments There are multiple ways of whipping together a command line argument parser for shell scripts. None is quite on par with Python’s argparse but that doesn’t mean we won’t try!\nAll we want is to create user-friendly Bash scripts that can be run like this:\n$ my-awedome-script -a --fast --file myfile.txt execute General form From a bird’s eye perspective, scripts have this general form:\n$ script-name [] [--] [] optional: optional arguments, e.g. -a, -abc. --some-flag. positional: positional arguments for which the order matters. --: End of options. What follows this are positional arguments. In other words, optional arguments need to be given with some kind of name, or pre-defined identifier preceeded by one or two hyphens, whereas positional arguments get their meaning from the order in which they appear.\nThe world is messier, though The world is much messier than that. Consider the following.\ndocker -D run -it ubuntu --rm What this command does is not important, look only at how the arguments are passed. This exemplifies a few things:\nThere are short and long options (e.g. -i and --rm). Some program don’t enforce that positional arguments come last (e.g. ubuntu --rm). Short options sometimes can be combined: -i -t == -it Some commands have subcommands, and both can have their on options (e.g. docker -D and run -it --rm, where run is a subcommand of docker). Moreover, there are different styles of options out there:\nps aux This is the BSD option style for the ps command, and the short options are combined, but not preceeded by a hyphen. We will hapilly ignore this form, unless, of course, we are running ps. Be advised, though that ps does support the more usual hyphenated form, if you prefer.\nPositional arguments: pretty easy Positional arguments are those that take their meaning from the order in which they appear when calling a script, for example:\n$ script arg1 arg2 arg3 # $0 $1 $2 $3 In Bash all arguments (optional or positional) can be accessed via the variables $0 through $9. If you have even more arguments you will need the curly braces: ${10}.\nIf your script has no optional arguments, the job is done:\n#!/bin/bash arg1=$1 arg2=$2 arg3=$3 ... Optional arguments: the hard part Due to the wild variety of ways available for passing optional arguments to a script, implementing a parser can be as complex as you wish.\nHere are a few suggestions in what is a pretty reasonable set of alternatives to get us started:\n1. script -a -b -c value # Separated, single letters. Option -c has a `value` 2. script -abc # Grouped. Equivalent to `-a -b -c`. 3. script -abc value # Grouped. Equivalent to `-a -b -c value`. 4. script --long-option # Long form option 5. script --long-option value # Long form with value 6. script --long-option=value # Long form with value From now we slowly introduce ways of dealing with the above options.\ngetopts This is probably the best cost/benefit parsing tool available to Bash scripts.\nBuilt-in command getopts is capable of skilfully parsing short-form optional arguments, but it only supports short-style options.\nThe general boiler-plate code looks like this:\nusage() { cat \u003c\u003c- EOF Usage: ${0##*/} [-abc] pos1 pos2 -a description. -b description. -c OUTFILE description. -h display this usage text. EOF } while getopts 'abc:h' opt; do case $opt in a) do-a;; b) do-b;; c) cvar=$OPTARG;; h) usage; exit 0;; \\?) usage; exit 1;; esac done shift \"$((OPTIND-1))\" pos1=$1 pos2=$2 The above shows that getopts takes a string argument telling it which options are possible. So getopt abc would allow for the options -a, -b and -c. In this string, if an argument ends with colon (:), then that option also takes a value, e.g. getopt a:b: would allow for -a value -b value.\nWe run getopt in a loop, and in each iteration it reads the argument pointed to by the $OPTIND variable, which starts at 1 (and that is extremely dumb, since things should be zero indexed).\nIn each iteration the following variables are set by getopts:\n$opt is the name of the current option discovered by getopts (e.g. a) $OPTARG is the value of the option $OPTIND is the position of the option (more on that soon) $0 $1 $2 $3 $4 $5 script -ab -c value pos1 pos2 | | | | | | | +-\u003e OPTIND=4, opt=c, OPTARG=value | | +-----\u003e OPTIND=3, skipped | +---------\u003e OPTIND=2, opt=a, opt=b +-----------------\u003e OPTIND=1, skipped At each loop these are the values of the relevant parameters:\nLoop opt OPTARG OPTIND 1 a 2 2 b 2 3 c value 4 And finally, we terminate with shift \"$((OPTIND-1))\" to fix up the argument array. This allows us to find the positional arguments.\n# After the `shift` operation the argument array looks like this: $0 $1 $2 script -ab -c value pos1 pos2 Parsign manually Using getopts is pretty convenient, but also limiting since it does not support long-form options and options with an optional value.\nThe following script shows how to manually parse arguments taking into account several possibilities using case and other built-in Bash facilities.\n# Adapted from Greg's Bash FAQ. while :; do case $1 in # Handle options with values, short and long form -c|--create) if [[ $2 ]]; then create=$2 shift else echo '`--create` argument is mandatory'; exit 1; fi ;; # Handle `=` as separator # Here we use parameter substitution e.g. ${varname#prefix-to-remove} --create=?*) create=${1#*=};; # Handle multiple verbose levels -v|--verbose) verbose=$((verbose + 1));; # Handle short and long forms without value -h|-\\?|--help) show_help; exit;; # End of options --) shift; break;; # Unknown option, print a warning to stderr -?*) printf 'WARN: Unknown option (ignored): %s\\n' \"$1\" \u003e\u00262;; # Default case, not an optional argument. Break out. *) break;; esac shift done [[ $create ]] || echo '`--create` argument is mandatory' \u0026\u0026 exit 1 git rev-parse An obscure, cryptically documented1, inaptly named, yet good complementary tool, is git-rev-parse. It does not do the entire job though. It only looks though and normalizes the argument list so you will have a much easier time parsing the arguments using the manual method described in the previous section.\nLet’s start with the example give in the documentation:\n#!/bin/bash OPTS_SPEC=\"\\ some-command [] ... some-command does foo and bar! -- h,help show the help foo some nifty option --foo bar= some cool option --bar with an argument baz=arg another cool option --baz with a named argument qux?path qux may take a path argument but has meaning by itself An option group Header C? option C with an optional argument\" eval \"$(echo \"$OPTS_SPEC\" | git rev-parse --parseopt -- \"$@\" || echo exit $?)\" print \"$@\" The above demonstrates that things are done in 4 steps:\nCreate an option parsing specification There you define how your options should be interpreted by git-rev-parse. Pipe the option specification to git-rev-parse standard input, and give it \"$@\" as arguments. eval the output of git-rev-parse. You now have a brand new argument array (\"$@\"), with normalized arguments. Let’s examine each step carefully.\n1. Option format specification This command expects a “option format specification” in the standard input, and the syntax for it is pretty straight forward, from the documentation:\nsome-command [] ... some-command does foo and bar! -- h,help show the help foo some nifty option --foo bar= some cool option --bar with an argument baz=arg another cool option --baz with a named argument qux?path qux may take a path argument but has meaning by itself An option group Header C? option C with an optional argument It starts with a description of the command in free text format. The description ends when a line containing -- is found.\n2. git rev-parse --parseopt Thai massage All that git rev-parse --parseopt really does is to normalize the input argument array. A normilized argument list is very easy to parse because:\nPositional arguments are easy to detect: All non-option arguments (i.e. positional) are moved all the way to the right. At the end of the options, there will aways be a -- delimiter. # This input $ script -opt1 pos1 --opt2 pos2 # becomes $ script --opt1 --opt2 -- pos1 pos2 Optional arguments are nice and tidy: Combined short-form arguments are split appart Options with values are always space-separated (i.e. no --opt=val) # This input $ script -abcd -e value1 --bar pos1 --baz=value2 # Becomes $ script -a -b -c -d -e value1 --bar --baz value2 -- pos1 The -h and --help optional arguments are intercepted and help is printed on standard output (i.e. not on standard error). In this case the command also reports the error code 129, for you to act upon.\nWhen wrong options are passed to the script, the help text is printed on standard error andthe error code 129 is reported for you to act upon.\n3. eval the output The “Thai massaged” output of git rev-parse --parseopt is, in fact a string that can be evald, and once that is done the argument array is reshuffled.\nWithout the eval you’d have this instead:\n$ myscript --foo pos1 --bar value pos2 set -- --foo --bar 'value' -- 'pos1' 'pos2' This set command gets printed, but it not executed. If we do execute it the following happens\narguments $0 $1 $2 $3 $4 $5 $6 before myscript --foo pos1 --bar value pos2 after myscript --foo --bar value -- pos1 pos2 4. Now you’re ready to start parsing ;) Now, no matter how messy the input your user passed to the script was, you have a nice and massaged argument array to work with. Simply use the manual parsing method.\nA fully functional copy/paste example #!/bin/bash OPTS_SPEC=\"\\ ${0##*/} [] [--] some-command does foo and bar! positional argument 1 positional argument 2 -- h,help show the help f,foo some nifty option --foo bar= some cool option --bar with an argument baz=arg another cool option --baz with a named argument qux?path qux may take a path argument but has meaning by itself An option group Header C? option C with an optional argument\" # Global variables representing the options foo=false bar= baz= qux=default-value # The output from `git rev-parse --parseopt`, in case we need to parse twice, # (e.g. when we have subcommands) set_args= # Positional arguments pos1= pos2= parse_args() { set_args=\"$(echo \"$OPTS_SPEC\" | git rev-parse --parseopt -- \"$@\" || echo exit $?)\" eval \"$set_args\" while (( $# \u003e 2 )); do opt=$1 shift echo \"opt: $opt, $*\" case \"$opt\" in -f|--foo) foo=true ;; --bar) bar=$1; shift ;; --baz) baz=$1; shift ;; # Optional value arguments are broken. Git does not inject an empty # argument for us to know whether or not an argument was passed. # Sad. --qux) [[ $1 ]] \u0026\u0026 qux=$1 \u0026\u0026 shift ;; esac done pos1=$1 pos2=$2 if [[ -z $pos1 ]] || [[ -z $pos2 ]]; then echo \"Positional parameters are required\" exit 1 fi } main() { parse_args \"$@\" # do something } main \"$@\" Another tool yet: parseopt, oh gosh! The problem with parseopt is that there are 2 versions of the same program out there, which is incredibly unfortunate.\nparseotp is a Unix utility that breaks in many situations in modern shell environments, where file names with white spaces are common places. So long story short, avoid it if you can.\nThen a group of Linux devs decided to fix the parseopt utility, and bundle it in something called util-linux, making it available in all Linux systems. But they didn’t change the name :face-palm:!\nSince we’re concerning ourselves only with Bash in this post, and Bash runs on MacOS and other non-Linux systems, it is impossible to know for sure what parseopt will do in the environment where it runs. What a bummer.\nFret not – parse opt does more or less the same thing as git rev-parse --parseopt, with the different that even the util-linux fixed up version does a worse job. So if you really need some advanced option parsing, use Git!\nHowever, if you are no Linux, don’t have Git available (I mean… nobody, nowadays) you can see an example of --parseopt in action installed in your system right now. head to man parseopt and scroll to the bottom to find the location. On Ubuntu 22.04 it is /usr/share/doc/util-linux/examples/getopt-example.bash.\nSomeone has actually contacted the authors of the git-rev-parse man page asking for improvements to readbility and they answered: “I’ve read it again, what part don’t you understand?”\nI’d say, well, I understand most of it, but it is so badly organized that it irks in me. Maybe I will be the one to fix it some day.\" I suspect that the documentaiton for git-rev-parse is the main reason behind the existence of the Git man page generator.\nSo when reading the git-rev-parse documentation jump straight to the PARSEOPT section. ↩︎\n","wordCount":"2284","inLanguage":"en","datePublished":"2023-02-20T14:50:00+01:00","dateModified":"2023-02-20T14:50:00+01:00","author":{"@type":"Person","name":"Lucas Viana"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lucas-viana.com/posts/bash-argparse/"},"publisher":{"@type":"Organization","name":"Lucas Viana's ruminations","logo":{"@type":"ImageObject","url":"https://lucas-viana.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lucas-viana.com accesskey=h title="Lucas Viana's ruminations (Alt + H)">Lucas Viana's ruminations</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lucas-viana.com>Home</a>&nbsp;»&nbsp;<a href=https://lucas-viana.com/posts/></a></div><h1 class=post-title>Parsing command line arguments in Bash</h1><div class=post-description>The best ways to parse arguments, and some script skeletons</div><div class=post-meta><span title='2023-02-20 14:50:00 +0100 +0100'>February 20, 2023</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Lucas Viana&nbsp;|&nbsp;<a href=https://github.com/senhorlucas/senhorlucas.github.io/tree/main/docs/content/posts/bash-argparse.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#the-goal aria-label="The goal">The goal</a></li><li><a href=#parsing-arguments aria-label="Parsing arguments">Parsing arguments</a></li><li><a href=#general-form aria-label="General form">General form</a></li><li><a href=#the-world-is-messier-though aria-label="The world is messier, though">The world is messier, though</a></li><li><a href=#positional-arguments-pretty-easy aria-label="Positional arguments: pretty easy">Positional arguments: pretty easy</a></li><li><a href=#optional-arguments-the-hard-part aria-label="Optional arguments: the hard part">Optional arguments: the hard part</a></li><li><a href=#getopts aria-label=getopts><code>getopts</code></a></li><li><a href=#parsign-manually aria-label="Parsign manually">Parsign manually</a></li><li><a href=#git-rev-parse aria-label="git rev-parse"><code>git rev-parse</code></a><ul><li><a href=#1-option-format-specification aria-label="1. Option format specification">1. Option format specification</a></li><li><a href=#2-git-rev-parse---parseopt-thai-massage aria-label="2. git rev-parse --parseopt Thai massage">2. <code>git rev-parse --parseopt</code> Thai massage</a></li><li><a href=#3-eval-the-output aria-label="3. eval the output">3. <code>eval</code> the output</a></li><li><a href=#4-now-youre-ready-to-start-parsing- aria-label="4. Now you&amp;rsquo;re ready to start parsing ;)">4. Now you&rsquo;re ready to start parsing ;)</a></li><li><a href=#a-fully-functional-copypaste-example aria-label="A fully functional copy/paste example">A fully functional copy/paste example</a></li></ul></li><li><a href=#another-tool-yet-parseopt-oh-gosh aria-label="Another tool yet: parseopt, oh gosh!">Another tool yet: <code>parseopt</code>, oh gosh!</a></li></ul></div></details></div><div class=post-content><p>If you don&rsquo;t have a CLI option parser in your scripts, you don&rsquo;t have scripts,
you have childish cake recipes.</p><p>As a software developer, you are the product of the systems you&rsquo;ve built to
assist you in your thinking. I&rsquo;ve heard the following phrase somewhere, so I
won&rsquo;t take credit:</p><blockquote><p>We should minize the time spent getting in position to think.</p></blockquote><p>Then we should be writing scripts that are capable of handling our use-cases
efficiently, without the constant need for us to go in and hack it up further.</p><h2 id=the-goal>The goal<a hidden class=anchor aria-hidden=true href=#the-goal>#</a></h2><p>We want to write our Bash scripts so we can invoke them with a multitude of
input options, so the script does the work without us needing to open it in the
editor.</p><p>We also want scritps that we can simply <code>./call-it --help</code>. And quickly be
reminded of the syntax to invoke it.</p><h2 id=parsing-arguments>Parsing arguments<a hidden class=anchor aria-hidden=true href=#parsing-arguments>#</a></h2><p>There are multiple ways of whipping together a command line argument parser for
shell scripts. None is quite on par with Python&rsquo;s <code>argparse</code> but that doesn&rsquo;t
mean we won&rsquo;t try!</p><p>All we want is to create user-friendly Bash scripts that can be run like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ my-awedome-script -a --fast --file myfile.txt execute
</span></span></code></pre></div><h2 id=general-form>General form<a hidden class=anchor aria-hidden=true href=#general-form>#</a></h2><p>From a bird&rsquo;s eye perspective, scripts have this general form:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ script-name <span style=color:#f92672>[</span>&lt;optional&gt;<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>--<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>&lt;positional&gt;<span style=color:#f92672>]</span>
</span></span></code></pre></div><ul><li><code>optional</code>: optional arguments, e.g. <code>-a</code>, <code>-abc</code>. <code>--some-flag</code>.</li><li><code>positional</code>: positional arguments for which the order matters.</li><li><code>--</code>: End of options. What follows this are positional arguments.</li></ul><p>In other words, optional arguments need to be given with some kind of name, or
pre-defined identifier preceeded by one or two hyphens, whereas positional
arguments get their meaning from the order in which they appear.</p><h2 id=the-world-is-messier-though>The world is messier, though<a hidden class=anchor aria-hidden=true href=#the-world-is-messier-though>#</a></h2><p>The world is much messier than that. Consider the following.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>docker -D run -it ubuntu --rm
</span></span></code></pre></div><p>What this command does is not important, look only at how the arguments are
passed. This exemplifies a few things:</p><ul><li>There are short and long options (e.g. <code>-i</code> and <code>--rm</code>).</li><li>Some program don&rsquo;t enforce that positional arguments come last (e.g.
<code>ubuntu --rm</code>).</li><li>Short options sometimes can be combined: <code>-i -t == -it</code></li><li>Some commands have subcommands, and both can have their on options (e.g.
<code>docker -D</code> and <code>run -it --rm</code>, where <code>run</code> is a subcommand of <code>docker</code>).</li></ul><p>Moreover, there are different styles of options out there:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>ps aux
</span></span></code></pre></div><p>This is the BSD option style for the <code>ps</code> command, and the short options are
combined, but not preceeded by a hyphen. We will hapilly ignore this form,
unless, of course, we are running <code>ps</code>. Be advised, though that <code>ps</code> does
support the more usual hyphenated form, if you prefer.</p><h2 id=positional-arguments-pretty-easy>Positional arguments: pretty easy<a hidden class=anchor aria-hidden=true href=#positional-arguments-pretty-easy>#</a></h2><p>Positional arguments are those that take their meaning from the order in which
they appear when calling a script, for example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ script arg1 arg2 arg3
</span></span><span style=display:flex><span><span style=color:#75715e># $0     $1   $2   $3</span>
</span></span></code></pre></div><p>In Bash all arguments (optional or positional) can be accessed via the variables
<code>$0</code> through <code>$9</code>. If you have even more arguments you will need the curly
braces: <code>${10}</code>.</p><p>If your script has no optional arguments, the job is done:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>arg1<span style=color:#f92672>=</span>$1
</span></span><span style=display:flex><span>arg2<span style=color:#f92672>=</span>$2
</span></span><span style=display:flex><span>arg3<span style=color:#f92672>=</span>$3
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h2 id=optional-arguments-the-hard-part>Optional arguments: the hard part<a hidden class=anchor aria-hidden=true href=#optional-arguments-the-hard-part>#</a></h2><p>Due to the wild variety of ways available for passing optional arguments to a
script, implementing a parser can be as complex as you wish.</p><p>Here are a few suggestions in what is a pretty reasonable set of alternatives
to get us started:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>1. script -a -b -c value   <span style=color:#75715e># Separated, single letters. Option -c has a `value`</span>
</span></span><span style=display:flex><span>2. script -abc             <span style=color:#75715e># Grouped. Equivalent to `-a -b -c`.</span>
</span></span><span style=display:flex><span>3. script -abc value       <span style=color:#75715e># Grouped. Equivalent to `-a -b -c value`.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>4. script --long-option        <span style=color:#75715e># Long form option</span>
</span></span><span style=display:flex><span>5. script --long-option value  <span style=color:#75715e># Long form with value</span>
</span></span><span style=display:flex><span>6. script --long-option<span style=color:#f92672>=</span>value  <span style=color:#75715e># Long form with value</span>
</span></span></code></pre></div><p>From now we slowly introduce ways of dealing with the above options.</p><h2 id=getopts><code>getopts</code><a hidden class=anchor aria-hidden=true href=#getopts>#</a></h2><p>This is probably the best cost/benefit parsing tool available to Bash scripts.</p><p>Built-in command <code>getopts</code> is capable of skilfully parsing short-form optional
arguments, but it only supports short-style options.</p><p>The general boiler-plate code looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>usage<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	cat <span style=color:#e6db74>&lt;&lt;- EOF
</span></span></span><span style=display:flex><span><span style=color:#e6db74>		Usage: ${0##*/} [-abc] pos1 pos2
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>		    -a          description.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>		    -b          description.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>		    -c OUTFILE  description.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            -h          display this usage text.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>		EOF</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> getopts <span style=color:#e6db74>&#39;abc:h&#39;</span> opt; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> $opt in
</span></span><span style=display:flex><span>		a<span style=color:#f92672>)</span> <span style=color:#66d9ef>do</span>-a;;
</span></span><span style=display:flex><span>		b<span style=color:#f92672>)</span> <span style=color:#66d9ef>do</span>-b;;
</span></span><span style=display:flex><span>		c<span style=color:#f92672>)</span> cvar<span style=color:#f92672>=</span>$OPTARG;;
</span></span><span style=display:flex><span>        h<span style=color:#f92672>)</span> usage; exit 0;;
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>\?</span><span style=color:#f92672>)</span> usage; exit 1;;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>esac</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span>shift <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$((</span>OPTIND-1<span style=color:#66d9ef>))</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pos1<span style=color:#f92672>=</span>$1
</span></span><span style=display:flex><span>pos2<span style=color:#f92672>=</span>$2
</span></span></code></pre></div><p>The above shows that <code>getopts</code> takes a string argument telling it which options
are possible. So <code>getopt abc</code> would allow for the options <code>-a</code>, <code>-b</code> and <code>-c</code>.
In this string, if an argument ends with colon (<code>:</code>), then that option also
takes a value, e.g. <code>getopt a:b:</code> would allow for <code>-a value -b value</code>.</p><p>We run <code>getopt</code> in a loop, and in each iteration it reads the argument pointed
to by the <code>$OPTIND</code> variable, which starts at 1 (and that is extremely dumb,
since things should be zero indexed).</p><p>In each iteration the following variables are set by <code>getopts</code>:</p><ul><li><code>$opt</code> is the name of the current option discovered by <code>getopts</code> (e.g. <code>a</code>)</li><li><code>$OPTARG</code> is the value of the option</li><li><code>$OPTIND</code> is the position of the option (more on that soon)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$0     $1  $2 $3    $4   $5
</span></span><span style=display:flex><span>script -ab -c value pos1 pos2
</span></span><span style=display:flex><span>|       |   |   |
</span></span><span style=display:flex><span>|       |   |   +-&gt; OPTIND=4, opt=c, OPTARG=value
</span></span><span style=display:flex><span>|       |   +-----&gt; OPTIND=3, skipped
</span></span><span style=display:flex><span>|       +---------&gt; OPTIND=2, opt=a, opt=b
</span></span><span style=display:flex><span>+-----------------&gt; OPTIND=1, skipped
</span></span></code></pre></div><p>At each loop these are the values of the relevant parameters:</p><table><thead><tr><th>Loop</th><th>opt</th><th>OPTARG</th><th>OPTIND</th></tr></thead><tbody><tr><td>1</td><td><code>a</code></td><td></td><td>2</td></tr><tr><td>2</td><td><code>b</code></td><td></td><td>2</td></tr><tr><td>3</td><td><code>c</code></td><td><code>value</code></td><td>4</td></tr></tbody></table><p>And finally, we terminate with <code>shift "$((OPTIND-1))"</code> to fix up the argument
array. This allows us to find the positional arguments.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash><span style=display:flex><span><span style=color:#75715e># After the `shift` operation the argument array looks like this:</span>
</span></span><span style=display:flex><span>$0                  $1   $2
</span></span><span style=display:flex><span>script -ab -c value pos1 pos2
</span></span></code></pre></div><h2 id=parsign-manually>Parsign manually<a hidden class=anchor aria-hidden=true href=#parsign-manually>#</a></h2><p>Using <code>getopts</code> is pretty convenient, but also limiting since it does not
support long-form options and options with an optional value.</p><p>The following script shows how to manually parse arguments taking into account
several possibilities using <code>case</code> and other built-in Bash facilities.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Adapted from Greg&#39;s Bash FAQ.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> :; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> $1 in
</span></span><span style=display:flex><span>        <span style=color:#75715e># Handle options with values, short and long form</span>
</span></span><span style=display:flex><span>        -c|--create<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> $2 <span style=color:#f92672>]]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>                create<span style=color:#f92672>=</span>$2
</span></span><span style=display:flex><span>                shift
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                echo <span style=color:#e6db74>&#39;`--create` argument is mandatory&#39;</span>; exit 1;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>            ;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Handle `=` as separator</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Here we use parameter substitution e.g. ${varname#prefix-to-remove}</span>
</span></span><span style=display:flex><span>        --create<span style=color:#f92672>=</span>?*<span style=color:#f92672>)</span> create<span style=color:#f92672>=</span><span style=color:#e6db74>${</span>1#*=<span style=color:#e6db74>}</span>;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Handle multiple verbose levels</span>
</span></span><span style=display:flex><span>        -v|--verbose<span style=color:#f92672>)</span> verbose<span style=color:#f92672>=</span><span style=color:#66d9ef>$((</span>verbose <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#66d9ef>))</span>;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Handle short and long forms without value</span>
</span></span><span style=display:flex><span>        -h|-<span style=color:#ae81ff>\?</span>|--help<span style=color:#f92672>)</span> show_help; exit;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># End of options</span>
</span></span><span style=display:flex><span>        --<span style=color:#f92672>)</span> shift; break;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Unknown option, print a warning to stderr</span>
</span></span><span style=display:flex><span>        -?*<span style=color:#f92672>)</span> printf <span style=color:#e6db74>&#39;WARN: Unknown option (ignored): %s\n&#39;</span> <span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span> &gt;&amp;2;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Default case, not an optional argument. Break out.</span>
</span></span><span style=display:flex><span>        *<span style=color:#f92672>)</span> break;;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>esac</span>
</span></span><span style=display:flex><span>    shift
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[[</span> $create <span style=color:#f92672>]]</span> <span style=color:#f92672>||</span> echo <span style=color:#e6db74>&#39;`--create` argument is mandatory&#39;</span> <span style=color:#f92672>&amp;&amp;</span> exit <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><h2 id=git-rev-parse><code>git rev-parse</code><a hidden class=anchor aria-hidden=true href=#git-rev-parse>#</a></h2><p>An obscure, cryptically documented<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, inaptly named, yet <em>good</em> complementary
tool, is <code>git-rev-parse</code>. It does not do the entire job though. It only looks
though and <em>normalizes</em> the argument list so you will have a much easier time
parsing the arguments using the manual method described in the previous section.</p><p>Let&rsquo;s start with the example give in the documentation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>OPTS_SPEC<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;\
</span></span></span><span style=display:flex><span><span style=color:#e6db74>some-command [&lt;options&gt;] &lt;args&gt;...
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>some-command does foo and bar!
</span></span></span><span style=display:flex><span><span style=color:#e6db74>--
</span></span></span><span style=display:flex><span><span style=color:#e6db74>h,help    show the help
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>foo       some nifty option --foo
</span></span></span><span style=display:flex><span><span style=color:#e6db74>bar=      some cool option --bar with an argument
</span></span></span><span style=display:flex><span><span style=color:#e6db74>baz=arg   another cool option --baz with a named argument
</span></span></span><span style=display:flex><span><span style=color:#e6db74>qux?path  qux may take a path argument but has meaning by itself
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>An option group Header
</span></span></span><span style=display:flex><span><span style=color:#e6db74>C?        option C with an optional argument&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>eval <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>echo <span style=color:#e6db74>&#34;</span>$OPTS_SPEC<span style=color:#e6db74>&#34;</span> | git rev-parse --parseopt -- <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>||</span> echo exit $?<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><p>The above demonstrates that things are done in 4 steps:</p><ol><li>Create an <em>option parsing specification</em> There you define how your options
should be interpreted by <code>git-rev-parse</code>.</li><li>Pipe the option specification to <code>git-rev-parse</code> standard input, and give it
<code>"$@"</code> as arguments.</li><li><code>eval</code> the output of <code>git-rev-parse</code>.</li><li>You now have a brand new argument array (<code>"$@"</code>), with normalized arguments.</li></ol><p>Let&rsquo;s examine each step carefully.</p><h3 id=1-option-format-specification>1. Option format specification<a hidden class=anchor aria-hidden=true href=#1-option-format-specification>#</a></h3><p>This command expects a &ldquo;option format specification&rdquo; in the standard input, and
the syntax for it is pretty straight forward, from the documentation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>some-command [&lt;options&gt;] &lt;args&gt;...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>some-command does foo and bar!
</span></span><span style=display:flex><span>--
</span></span><span style=display:flex><span>h,help    show the help
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>foo       some nifty option --foo
</span></span><span style=display:flex><span>bar=      some cool option --bar with an argument
</span></span><span style=display:flex><span>baz=arg   another cool option --baz with a named argument
</span></span><span style=display:flex><span>qux?path  qux may take a path argument but has meaning by itself
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>An option group Header
</span></span><span style=display:flex><span>C?        option C with an optional argument
</span></span></code></pre></div><p>It starts with a description of the command in free text format. The description
ends when a line containing <code>--</code> is found.</p><h3 id=2-git-rev-parse---parseopt-thai-massage>2. <code>git rev-parse --parseopt</code> Thai massage<a hidden class=anchor aria-hidden=true href=#2-git-rev-parse---parseopt-thai-massage>#</a></h3><p>All that <code>git rev-parse --parseopt</code> really does is to normalize the input
argument array. A normilized argument list is very easy to parse because:</p><ul><li>Positional arguments are easy to detect:<ul><li>All non-option arguments (i.e. positional) are moved all the way to the
right.</li><li>At the end of the options, there will aways be a <code>--</code> delimiter.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># This input</span>
</span></span><span style=display:flex><span>$ script -opt1 pos1 --opt2 pos2
</span></span><span style=display:flex><span><span style=color:#75715e># becomes</span>
</span></span><span style=display:flex><span>$ script --opt1 --opt2 -- pos1 pos2
</span></span></code></pre></div><ul><li>Optional arguments are nice and tidy:<ul><li>Combined short-form arguments are split appart</li><li>Options with values are always space-separated (i.e. no <code>--opt=val</code>)</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># This input</span>
</span></span><span style=display:flex><span>$ script -abcd -e value1 --bar pos1 --baz<span style=color:#f92672>=</span>value2
</span></span><span style=display:flex><span><span style=color:#75715e># Becomes</span>
</span></span><span style=display:flex><span>$ script -a -b -c -d -e value1 --bar --baz value2 -- pos1
</span></span></code></pre></div><ul><li><p>The <code>-h</code> and <code>--help</code> optional arguments are intercepted and help is printed
on <em>standard output</em> (i.e. not on <em>standard error</em>).
In this case the command also reports the error code <code>129</code>, for <em>you</em> to act
upon.</p></li><li><p>When wrong options are passed to the script, the help text is printed on
<em>standard error</em> andthe error code <code>129</code> is reported for <em>you</em> to act upon.</p></li></ul><h3 id=3-eval-the-output>3. <code>eval</code> the output<a hidden class=anchor aria-hidden=true href=#3-eval-the-output>#</a></h3><p>The &ldquo;Thai massaged&rdquo; output of <code>git rev-parse --parseopt</code> is, in fact a string
that can be <code>eval</code>d, and once that is done the argument array is reshuffled.</p><p>Without the eval you&rsquo;d have this instead:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ myscript --foo pos1 --bar value pos2
</span></span><span style=display:flex><span>set -- --foo --bar <span style=color:#e6db74>&#39;value&#39;</span> -- <span style=color:#e6db74>&#39;pos1&#39;</span> <span style=color:#e6db74>&#39;pos2&#39;</span>
</span></span></code></pre></div><p>This <code>set</code> command gets printed, but it not executed. If we do execute it the
following happens</p><table><thead><tr><th>arguments</th><th><code>$0</code></th><th><code>$1</code></th><th><code>$2</code></th><th><code>$3</code></th><th><code>$4</code></th><th><code>$5</code></th><th><code>$6</code></th></tr></thead><tbody><tr><td>before</td><td><code>myscript</code></td><td><code>--foo</code></td><td><code>pos1</code></td><td><code>--bar</code></td><td><code>value</code></td><td><code>pos2</code></td><td></td></tr><tr><td>after</td><td><code>myscript</code></td><td><code>--foo</code></td><td><code>--bar</code></td><td><code>value</code></td><td><code>--</code></td><td><code>pos1</code></td><td><code>pos2</code></td></tr></tbody></table><h3 id=4-now-youre-ready-to-start-parsing->4. Now you&rsquo;re ready to start parsing ;)<a hidden class=anchor aria-hidden=true href=#4-now-youre-ready-to-start-parsing->#</a></h3><p>Now, no matter how messy the input your user passed to the script was, you have
a nice and massaged argument array to work with. Simply use the manual parsing
method.</p><h3 id=a-fully-functional-copypaste-example>A fully functional copy/paste example<a hidden class=anchor aria-hidden=true href=#a-fully-functional-copypaste-example>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>OPTS_SPEC<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;\
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#e6db74>${</span>0##*/<span style=color:#e6db74>}</span><span style=color:#e6db74> [&lt;options&gt;] [--] &lt;pos1&gt; &lt;pos2&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>some-command does foo and bar!
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&lt;pos1&gt;    positional argument 1
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&lt;pos2&gt;    positional argument 2
</span></span></span><span style=display:flex><span><span style=color:#e6db74>--
</span></span></span><span style=display:flex><span><span style=color:#e6db74>h,help    show the help
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>f,foo       some nifty option --foo
</span></span></span><span style=display:flex><span><span style=color:#e6db74>bar=      some cool option --bar with an argument
</span></span></span><span style=display:flex><span><span style=color:#e6db74>baz=arg   another cool option --baz with a named argument
</span></span></span><span style=display:flex><span><span style=color:#e6db74>qux?path  qux may take a path argument but has meaning by itself
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>An option group Header
</span></span></span><span style=display:flex><span><span style=color:#e6db74>C?        option C with an optional argument&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Global variables representing the options</span>
</span></span><span style=display:flex><span>foo<span style=color:#f92672>=</span>false
</span></span><span style=display:flex><span>bar<span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>baz<span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>qux<span style=color:#f92672>=</span>default-value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># The output from `git rev-parse --parseopt`, in case we need to parse twice,</span>
</span></span><span style=display:flex><span><span style=color:#75715e># (e.g. when we have subcommands)</span>
</span></span><span style=display:flex><span>set_args<span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Positional arguments</span>
</span></span><span style=display:flex><span>pos1<span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>pos2<span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>parse_args<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	set_args<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>echo <span style=color:#e6db74>&#34;</span>$OPTS_SPEC<span style=color:#e6db74>&#34;</span> | git rev-parse --parseopt -- <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>||</span> echo exit $?<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	eval <span style=color:#e6db74>&#34;</span>$set_args<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> <span style=color:#f92672>((</span> $# &gt; <span style=color:#ae81ff>2</span> <span style=color:#f92672>))</span>; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>		opt<span style=color:#f92672>=</span>$1
</span></span><span style=display:flex><span>		shift
</span></span><span style=display:flex><span>		echo <span style=color:#e6db74>&#34;opt: </span>$opt<span style=color:#e6db74>, </span>$*<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;</span>$opt<span style=color:#e6db74>&#34;</span> in
</span></span><span style=display:flex><span>			-f|--foo<span style=color:#f92672>)</span> foo<span style=color:#f92672>=</span>true ;;
</span></span><span style=display:flex><span>			--bar<span style=color:#f92672>)</span> bar<span style=color:#f92672>=</span>$1; shift ;;
</span></span><span style=display:flex><span>			--baz<span style=color:#f92672>)</span> baz<span style=color:#f92672>=</span>$1; shift ;;
</span></span><span style=display:flex><span>			<span style=color:#75715e># Optional value arguments are broken. Git does not inject an empty</span>
</span></span><span style=display:flex><span>			<span style=color:#75715e># argument for us to know whether or not an argument was passed.</span>
</span></span><span style=display:flex><span>			<span style=color:#75715e># Sad.</span>
</span></span><span style=display:flex><span>			--qux<span style=color:#f92672>)</span> <span style=color:#f92672>[[</span> $1 <span style=color:#f92672>]]</span> <span style=color:#f92672>&amp;&amp;</span> qux<span style=color:#f92672>=</span>$1 <span style=color:#f92672>&amp;&amp;</span> shift ;;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>esac</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	pos1<span style=color:#f92672>=</span>$1
</span></span><span style=display:flex><span>	pos2<span style=color:#f92672>=</span>$2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> -z $pos1 <span style=color:#f92672>]]</span> <span style=color:#f92672>||</span> <span style=color:#f92672>[[</span> -z $pos2 <span style=color:#f92672>]]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>		echo <span style=color:#e6db74>&#34;Positional parameters are required&#34;</span>
</span></span><span style=display:flex><span>		exit <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>	parse_args <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># do something</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><h2 id=another-tool-yet-parseopt-oh-gosh>Another tool yet: <code>parseopt</code>, oh gosh!<a hidden class=anchor aria-hidden=true href=#another-tool-yet-parseopt-oh-gosh>#</a></h2><p>The problem with <code>parseopt</code> is that there are 2 versions of the same program
out there, which is incredibly unfortunate.</p><p><code>parseotp</code> is a Unix utility that breaks in many situations in modern shell
environments, where file names with white spaces are common places. So long
story short, avoid it if you can.</p><p>Then a group of Linux devs decided to fix the <code>parseopt</code> utility, and bundle it
in something called <code>util-linux</code>, making it available in all Linux systems.
But they didn&rsquo;t change the name :face-palm:!</p><p>Since we&rsquo;re concerning ourselves only with Bash in this post, and Bash runs on
MacOS and other non-Linux systems, it is impossible to <em>know for sure</em> what
<code>parseopt</code> will do in the environment where it runs. What a bummer.</p><p>Fret not &ndash; <code>parse opt</code> does more or less the same thing as
<code>git rev-parse --parseopt</code>, with the different that even the <code>util-linux</code> fixed
up version does a worse job. So if you really need some advanced option parsing,
use Git!</p><p>However, if you are no Linux, don&rsquo;t have Git available (I mean&mldr; nobody,
nowadays) you can see an example of <code>--parseopt</code> in action installed in your
system right now. head to <code>man parseopt</code> and scroll to the bottom to find the
location. On Ubuntu 22.04 it is
<code>/usr/share/doc/util-linux/examples/getopt-example.bash</code>.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Someone has actually contacted the authors of the <code>git-rev-parse</code> man page
asking for improvements to readbility and they answered: &ldquo;I&rsquo;ve read it
again, what part don&rsquo;t you understand?&rdquo;</p><p>I&rsquo;d say, well, I understand most of it, but it is so badly organized that
it irks in me. Maybe I will be the one to fix it some day." I suspect that
the documentaiton for <code>git-rev-parse</code> is the main reason behind the
existence of the <a href=git-man-page-generator.lokaltog.net>Git man page generator</a>.</p><p>So when reading the <code>git-rev-parse</code> documentation jump straight to the
<em>PARSEOPT</em> section.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://lucas-viana.com/posts/sed/><span class=title>Next »</span><br><span>Learn `sed` and be happy</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Parsing command line arguments in Bash on twitter" href="https://twitter.com/intent/tweet/?text=Parsing%20command%20line%20arguments%20in%20Bash&amp;url=https%3a%2f%2flucas-viana.com%2fposts%2fbash-argparse%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Parsing command line arguments in Bash on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flucas-viana.com%2fposts%2fbash-argparse%2f&amp;title=Parsing%20command%20line%20arguments%20in%20Bash&amp;summary=Parsing%20command%20line%20arguments%20in%20Bash&amp;source=https%3a%2f%2flucas-viana.com%2fposts%2fbash-argparse%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Parsing command line arguments in Bash on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flucas-viana.com%2fposts%2fbash-argparse%2f&title=Parsing%20command%20line%20arguments%20in%20Bash"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Parsing command line arguments in Bash on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flucas-viana.com%2fposts%2fbash-argparse%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Parsing command line arguments in Bash on whatsapp" href="https://api.whatsapp.com/send?text=Parsing%20command%20line%20arguments%20in%20Bash%20-%20https%3a%2f%2flucas-viana.com%2fposts%2fbash-argparse%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Parsing command line arguments in Bash on telegram" href="https://telegram.me/share/url?text=Parsing%20command%20line%20arguments%20in%20Bash&amp;url=https%3a%2f%2flucas-viana.com%2fposts%2fbash-argparse%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://lucas-viana.com>Lucas Viana's ruminations</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>